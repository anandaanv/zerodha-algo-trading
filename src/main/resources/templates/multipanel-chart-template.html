<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>{{CHART_TITLE}}</title>
<!--    <script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>-->
    <script src="https://unpkg.com/lightweight-charts@5.0.2/dist/lightweight-charts.standalone.production.js"></script>
    <script>
        // Overlays payload injected by server, keyed by timeframe name
        const OVERLAYS = {{OVERLAYS_JSON}};
        const VISIBLE_BARS = {{VISIBLE_BARS}};
    </script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background-color: #000;
        }

        .chart-grid {
            display: grid;
            grid-template-columns: repeat({{CHART_GRID_COLS}}, 1fr);
            grid-template-rows: repeat({{CHART_GRID_ROWS}}, 1fr);
            gap: 10px;
            padding: 10px;
            background-color: #000;
            width: 100vw;
            height: 100vh;
            box-sizing: border-box;
        }

        .chart-cell {
            display: flex;
            flex-direction: column;
            background-color: #131722;
            border-radius: 5px;
            overflow: hidden;
        }

        .chart-title {
            font-size: 14px;
            font-weight: bold;
            color: #d1d4dc;
            padding: 10px;
            text-align: center;
            background-color: #1e222d;
        }

        .chart-container {
            flex: 1;
            width: 100%;
            height: calc(100% - 35px);
            position: relative;
        }

        .main-chart-container {
            height: 65%;
            width: 100%;
        }

        .indicator-panel {
            height: 17.5%;
            width: 100%;
            border-top: 1px solid #2B2B43;
        }
    </style>
</head>
<body>
    <div class="chart-grid">
        {{CHART_CONTAINERS}}
    </div>

    <script>
        // Data arrays and overlays injected by server (we keep existing CHART_INIT_SCRIPTS)
        function createChart(containerId, chartData, showVolume, timeframe) {
            const chartContainer = document.getElementById(containerId);

            const mainContainer = document.createElement('div');
            mainContainer.className = 'main-chart-container';
            chartContainer.appendChild(mainContainer);

            const chart = LightweightCharts.createChart(mainContainer, {
                layout: { background: { color: '#131722' }, textColor: '#d1d4dc' },
                grid: { vertLines: { color: '#1e222d' }, horzLines: { color: '#1e222d' } },
                timeScale: { borderColor: '#2B2B43', timeVisible: true },
                crosshair: {
                    vertLine: { color: '#6A5ACD', width: 1, style: 1 },
                    horzLine: { color: '#6A5ACD', width: 1, style: 1 },
                },
                rightPriceScale: { borderColor: '#2B2B43' },
                leftPriceScale: { visible: false },
                handleScroll: { mouseWheel: true, pressedMouseMove: true, horzTouchDrag: true },
                handleScale: { mouseWheel: true, pinch: true },
            });

            const candleSeries = chart.addSeries(LightweightCharts.CandlestickSeries, {
                upColor: '#26a69a', downColor: '#ef5350',
                borderVisible: false, wickUpColor: '#26a69a', wickDownColor: '#ef5350',
            });
            candleSeries.setData(chartData.candles);

            // EMA indicators on the main (right) price scale with hidden price labels
            if (chartData.ema50) {
                const ema50Series = chart.addSeries(LightweightCharts.LineSeries, {
                    color: '#FF6D00', lineWidth: 1,
                    lastValueVisible: false,
                    priceLineVisible: false
                });
                const ema50Data = chartData.candles.map((candle, index) => ({
                    time: candle.time, value: chartData.ema50[index]
                })).filter(item => item.value != null && !isNaN(item.value));
                ema50Series.setData(ema50Data);
            }
            if (chartData.ema100) {
                const ema100Series = chart.addSeries(LightweightCharts.LineSeries, {
                    color: '#2962FF', lineWidth: 1,
                    lastValueVisible: false,
                    priceLineVisible: false
                });
                const ema100Data = chartData.candles.map((candle, index) => ({
                    time: candle.time, value: chartData.ema100[index]
                })).filter(item => item.value != null && !isNaN(item.value));
                ema100Series.setData(ema100Data);
            }
            if (chartData.ema200) {
                const ema200Series = chart.addSeries(LightweightCharts.LineSeries, {
                    color: '#9C27B0', lineWidth: 1,
                    lastValueVisible: false,
                    priceLineVisible: false
                });
                const ema200Data = chartData.candles.map((candle, index) => ({
                    time: candle.time, value: chartData.ema200[index]
                })).filter(item => item.value != null && !isNaN(item.value));
                ema200Series.setData(ema200Data);
            }

            // Bollinger Bands on the main (right) price scale with hidden price labels
            if (chartData.bollingerUpper && chartData.bollingerMiddle && chartData.bollingerLower) {
                const bbUpperSeries = chart.addSeries(LightweightCharts.LineSeries, {
                    color: '#2962FF', lineWidth: 1,
                    lastValueVisible: false,
                    priceLineVisible: false
                });
                const bbMiddleSeries = chart.addSeries(LightweightCharts.LineSeries, {
                    color: '#FF6D00', lineWidth: 1,
                    lastValueVisible: false,
                    priceLineVisible: false
                });
                const bbLowerSeries = chart.addSeries(LightweightCharts.LineSeries, {
                    color: '#2962FF', lineWidth: 1,
                    lastValueVisible: false,
                    priceLineVisible: false
                });

                const bbUpperData = chartData.candles.map((candle, index) => ({
                    time: candle.time, value: chartData.bollingerUpper[index]
                })).filter(item => item.value != null && !isNaN(item.value));
                const bbMiddleData = chartData.candles.map((candle, index) => ({
                    time: candle.time, value: chartData.bollingerMiddle[index]
                })).filter(item => item.value != null && !isNaN(item.value));
                const bbLowerData = chartData.candles.map((candle, index) => ({
                    time: candle.time, value: chartData.bollingerLower[index]
                })).filter(item => item.value != null && !isNaN(item.value));

                bbUpperSeries.setData(bbUpperData);
                bbMiddleSeries.setData(bbMiddleData);
                bbLowerSeries.setData(bbLowerData);
            }

            // Volume (unchanged)
            if (showVolume && chartData.candles[0] && chartData.candles[0].volume !== undefined) {
                const volumeData = chartData.candles.map(item => ({
                    time: item.time,
                    value: item.volume,
                    color: item.close >= item.open ? 'rgba(38, 166, 154, 0.5)' : 'rgba(239, 83, 80, 0.5)'
                }));
                const volumeSeries = chart.addSeries(LightweightCharts.HistogramSeries, {
                    color: '#26a69a',
                    priceFormat: { type: 'volume' },
                    priceScaleId: '',
                    scaleMargins: { top: 0.8, bottom: 0 },
                });
                volumeSeries.setData(volumeData);
            }

            // Draw overlays (trendlines and zigzag segments encoded as trendlines)
            const ol = OVERLAYS && OVERLAYS[timeframe] ? OVERLAYS[timeframe] : null;
            if (ol && ol.trendlines && Array.isArray(ol.trendlines)) {
                ol.trendlines.forEach(tl => {
                    const style = tl.label === 'broken' ? LightweightCharts.LineStyle.Dotted
                              : tl.label === 'retesting' ? LightweightCharts.LineStyle.Dashed
                              : LightweightCharts.LineStyle.Solid;
                    const ls = chart.addSeries(LightweightCharts.LineSeries, {
                        color: tl.color || '#888888',
                        lineWidth: 2,
                        lineStyle: style,
                        priceScaleId: 'right',
                        lastValueVisible: false,
                        priceLineVisible: false,
                    });
                    ls.setData([
                        { time: tl.startTs, value: tl.startPrice },
                        { time: tl.endTs,   value: tl.endPrice }
                    ]);
                });
            }

            // Indicators panels (MACD, RSI) remain as-is...
            // (existing MACD/RSI code unchanged)

            // Synchronize time scales and cap visible range to last N bars
            chart.timeScale().subscribeVisibleTimeRangeChange(() => {
                const timeRange = chart.timeScale().getVisibleRange();
                if (macdChart && macdChart.timeScale) macdChart.timeScale().setVisibleRange(timeRange);
                if (rsiChart && rsiChart.timeScale) rsiChart.timeScale().setVisibleRange(timeRange);
            });

            const lastIndex = chartData.candles.length - 1;
            const from = Math.max(0, lastIndex - VISIBLE_BARS);
            chart.timeScale().setVisibleLogicalRange({ from: from, to: lastIndex + 5 });

            // Create MACD indicator panel
            const macdContainer = document.createElement('div');
            macdContainer.className = 'indicator-panel';
            chartContainer.appendChild(macdContainer);

            const macdChart = LightweightCharts.createChart(macdContainer, {
                layout: {
                    background: { color: '#131722' },
                    textColor: '#d1d4dc',
                },
                grid: {
                    vertLines: { color: '#1e222d' },
                    horzLines: { color: '#1e222d' },
                },
                timeScale: {
                    borderColor: '#2B2B43',
                    timeVisible: false,
                },
                crosshair: {
                    vertLine: {
                        color: '#6A5ACD',
                        width: 1,
                        style: 1,
                    },
                    horzLine: {
                        color: '#6A5ACD',
                        width: 1,
                        style: 1,
                    },
                },
                rightPriceScale: {
                    borderColor: '#2B2B43',
                },
                handleScroll: false,
                handleScale: false,
            });

            // Add MACD lines
            if (chartData.macdLine && chartData.macdSignal && chartData.macdHistogram) {
                const macdLineSeries = macdChart.addSeries(LightweightCharts.LineSeries, {
                    color: '#2962FF',
                    lineWidth: 1,
                    title: 'MACD',
                });

                const macdSignalSeries = macdChart.addSeries(LightweightCharts.LineSeries, {
                    color: '#FF6D00',
                    lineWidth: 1,
                    title: 'Signal',
                });

                const macdHistogramSeries = macdChart.addSeries(LightweightCharts.HistogramSeries, {
                    color: '#26a69a',
                    title: 'Histogram',
                });

                const macdLineData = chartData.candles.map((candle, index) => ({
                    time: candle.time,
                    value: chartData.macdLine[index]
                })).filter(item => item.value != null && !isNaN(item.value));

                const macdSignalData = chartData.candles.map((candle, index) => ({
                    time: candle.time,
                    value: chartData.macdSignal[index]
                })).filter(item => item.value != null && !isNaN(item.value));

                const macdHistogramData = chartData.candles.map((candle, index) => ({
                    time: candle.time,
                    value: chartData.macdHistogram[index],
                    color: chartData.macdHistogram[index] >= 0 ? '#26a69a' : '#ef5350'
                })).filter(item => item.value != null && !isNaN(item.value));

                macdLineSeries.setData(macdLineData);
                macdSignalSeries.setData(macdSignalData);
                macdHistogramSeries.setData(macdHistogramData);
            }

            // Create RSI indicator panel
            const rsiContainer = document.createElement('div');
            rsiContainer.className = 'indicator-panel';
            chartContainer.appendChild(rsiContainer);

            const rsiChart = LightweightCharts.createChart(rsiContainer, {
                layout: {
                    background: { color: '#131722' },
                    textColor: '#d1d4dc',
                },
                grid: {
                    vertLines: { color: '#1e222d' },
                    horzLines: { color: '#1e222d' },
                },
                timeScale: {
                    borderColor: '#2B2B43',
                    timeVisible: false,
                },
                crosshair: {
                    vertLine: {
                        color: '#6A5ACD',
                        width: 1,
                        style: 1,
                    },
                    horzLine: {
                        color: '#6A5ACD',
                        width: 1,
                        style: 1,
                    },
                },
                rightPriceScale: {
                    borderColor: '#2B2B43',
                    scaleMargins: {
                        top: 0.1,
                        bottom: 0.1,
                    },
                },
                handleScroll: false,
                handleScale: false,
            });

            // Add RSI line and reference lines
            if (chartData.rsi) {
                const rsiSeries = rsiChart.addSeries(LightweightCharts.LineSeries, {
                    color: '#2962FF',
                    lineWidth: 1,
                    title: 'RSI (14)',
                });

                // Add horizontal reference lines at 30 and 70
                const rsi30Series = rsiChart.addSeries(LightweightCharts.LineSeries, {
                    color: '#787B86',
                    lineWidth: 1,
                    lineStyle: 2, // Dashed line
                    title: '30',
                });

                const rsi70Series = rsiChart.addSeries(LightweightCharts.LineSeries, {
                    color: '#787B86',
                    lineWidth: 1,
                    lineStyle: 2, // Dashed line
                    title: '70',
                });

                const rsiData = chartData.candles.map((candle, index) => ({
                    time: candle.time,
                    value: chartData.rsi[index]
                })).filter(item => item.value != null && !isNaN(item.value));

                const rsi30Data = chartData.candles.map(candle => ({
                    time: candle.time,
                    value: 30
                }));

                const rsi70Data = chartData.candles.map(candle => ({
                    time: candle.time,
                    value: 70
                }));

                rsiSeries.setData(rsiData);
                rsi30Series.setData(rsi30Data);
                rsi70Series.setData(rsi70Data);
            }

            // Synchronize time scales
            chart.timeScale().subscribeVisibleTimeRangeChange(() => {
                const timeRange = chart.timeScale().getVisibleRange();
                macdChart.timeScale().setVisibleRange(timeRange);
                rsiChart.timeScale().setVisibleRange(timeRange);
            });

            // Set visible range to focus on the most recent data
            chart.timeScale().fitContent();

            // Redraw when container size changes
            const resizeObserver = new ResizeObserver(entries => {
                chart.applyOptions({ width: mainContainer.clientWidth, height: mainContainer.clientHeight });
                macdChart.applyOptions({ width: macdContainer.clientWidth, height: macdContainer.clientHeight });
                rsiChart.applyOptions({ width: rsiContainer.clientWidth, height: rsiContainer.clientHeight });
            });

            resizeObserver.observe(chartContainer);
            return { main: chart, macd: macdChart, rsi: rsiChart };
        }

        window.addEventListener('DOMContentLoaded', () => {
            // Initialize all charts
            {{CHART_INIT_SCRIPTS}}

            // Signal to the screenshot tool that rendering is complete
            window.setTimeout(() => {
                const readyElement = document.createElement('div');
                readyElement.id = 'chart-ready';
                readyElement.style.display = 'none';
                document.body.appendChild(readyElement);
            }, 1000);
        });
    </script>
        // Build all panels now
        (function initPanels() {
            for (let i = 0; i < TIMEFRAMES.length; i++) {
                const tf = TIMEFRAMES[i];
                const data = PANEL_DATA[i];
                const containerId = 'chart-container-' + tf;
                // Create chart and indicators
                createChart(containerId, data, true, tf);

                // Draw overlays for this timeframe on the main chart inside container
                // We need to re-select the chart element to fetch the last created chart instance if stored globally.
                // Simpler approach: re-create a small renderer in-place
                const chartElem = document.getElementById(containerId).firstChild; // main chart container
                // Assuming we can retrieve the instance via a global map, but if not, we simply add a new series via a stored reference.
                // For this template, we will re-add overlay series by creating an extra transparent chart on top is complex.
                // Instead, embed overlay drawing inside createChart below (advanced refactor), or store charts in a map.

                // Apply visible range
                // Note: createChart created a 'chart' variable scoped within. For strict correctness,
                // consider storing a window.charts[containerId] = chart inside createChart.
            }
        })();
    </script>
</body>
</html>
